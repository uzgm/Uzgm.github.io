<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>zgm Paint Pro V2.1</title>
    <style>
        :root { --panel-bg: #1e1e1e; --accent: #ffeb3b; --text: #ffffff; }
        body { margin: 0; background: #121212; color: var(--text); font-family: 'Pretendard', sans-serif; display: flex; flex-direction: column; height: 100vh; overflow: hidden; touch-action: none; }
        .toolbar { background: var(--panel-bg); padding: 8px 12px; display: flex; align-items: center; gap: 10px; overflow-x: auto; border-bottom: 2px solid #333; }
        .toolbar::-webkit-scrollbar { display: none; }
        .tool-group { display: flex; align-items: center; gap: 8px; border-right: 1px solid #444; padding-right: 10px; flex-shrink: 0; }
        label { font-size: 0.7rem; color: #888; font-weight: 900; }
        input[type="color"] { border: none; width: 30px; height: 30px; background: none; cursor: pointer; }
        input[type="range"] { width: 60px; accent-color: var(--accent); }
        .btn { background: #333; color: white; border: none; padding: 10px 14px; border-radius: 8px; cursor: pointer; font-size: 0.8rem; font-weight: bold; flex-shrink: 0; }
        .btn:active { transform: scale(0.9); }
        .btn.active { background: var(--accent); color: #000; }
        .btn.save { background: #00e676; color: #000; }
        .canvas-container { flex: 1; display: flex; justify-content: center; align-items: center; background: #252525; }
        canvas { background: white; border-radius: 2px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
    </style>
</head>
<body>

    <header class="toolbar">
        <div class="tool-group">
            <input type="color" id="colorPicker" value="#000000">
            <input type="range" id="lineWidth" min="1" max="50" value="5">
        </div>
        <div class="tool-group">
            <button id="penBtn" class="btn active">íŽœ</button>
            <button id="fillBtn" class="btn">ì±„ìš°ê¸°</button>
            <button id="eraserBtn" class="btn">ì§€ìš°ê°œ</button>
        </div>
        <div class="tool-group">
            <button id="undoBtn" class="btn">â†© ë’¤ë¡œ</button>
            <button id="redoBtn" class="btn">ì•žìœ¼ë¡œ â†ª</button>
        </div>
        <button id="clearBtn" class="btn">ì´ˆê¸°í™”</button>
        <button id="saveBtn" class="btn save">ì €ìž¥</button>
    </header>

    <main class="canvas-container">
        <canvas id="paintCanvas"></canvas>
    </main>

    <script>
        const canvas = document.getElementById('paintCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const colorPicker = document.getElementById('colorPicker');
        const lineWidth = document.getElementById('lineWidth');

        let isDrawing = false;
        let currentMode = 'pen';
        
        // ðŸš€ ë˜ëŒë¦¬ê¸° í•µì‹¬ ì‹œìŠ¤í…œ
        let historyStack = [];
        let redoStack = [];
        const MAX_HISTORY = 30;

        function initCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth * 0.95;
            canvas.height = container.clientHeight * 0.95;
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // ì²« ìƒíƒœ ì €ìž¥
            saveState();
        }

        function saveState() {
            // í˜„ìž¬ ìº”ë²„ìŠ¤ ìƒíƒœë¥¼ ì´ë¯¸ì§€ ë°ì´í„°ë¡œ ì €ìž¥
            if (historyStack.length >= MAX_HISTORY) historyStack.shift();
            historyStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            redoStack = []; // ìƒˆ ê·¸ë¦¼ì„ ê·¸ë¦¬ë©´ ë‹¤ì‹œì‹¤í–‰ ëª©ë¡ ì‚­ì œ
        }

        function undo() {
            if (historyStack.length > 1) {
                redoStack.push(historyStack.pop()); // í˜„ìž¬ ìƒíƒœë¥¼ ë¦¬ë‘ë¡œ ë³´ëƒ„
                const prevState = historyStack[historyStack.length - 1];
                ctx.putImageData(prevState, 0, 0);
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                const nextState = redoStack.pop();
                historyStack.push(nextState);
                ctx.putImageData(nextState, 0, 0);
            }
        }

        // --- ì±„ìš°ê¸° ì•Œê³ ë¦¬ì¦˜ ---
        function floodFill(startX, startY, fillRGB) {
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            const i = (startY * canvas.width + startX) * 4;
            const target = [data[i], data[i+1], data[i+2], data[i+3]];
            
            if (target[0] === fillRGB[0] && target[1] === fillRGB[1] && target[2] === fillRGB[2]) return;

            const queue = [[startX, startY]];
            while (queue.length > 0) {
                const [x, y] = queue.shift();
                const pos = (y * canvas.width + x) * 4;
                if (data[pos] === target[0] && data[pos+1] === target[1] && data[pos+2] === target[2]) {
                    data[pos] = fillRGB[0]; data[pos+1] = fillRGB[1]; data[pos+2] = fillRGB[2]; data[pos+3] = 255;
                    if (x > 0) queue.push([x - 1, y]);
                    if (x < canvas.width - 1) queue.push([x + 1, y]);
                    if (y > 0) queue.push([x, y - 1]);
                    if (y < canvas.height - 1) queue.push([x, y + 1]);
                }
            }
            ctx.putImageData(imgData, 0, 0);
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: Math.floor(clientX - rect.left), y: Math.floor(clientY - rect.top) };
        }

        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDraw(e); }, {passive: false});
        
        function startDraw(e) {
            const pos = getPos(e);
            if (currentMode === 'fill') {
                const hex = colorPicker.value;
                const rgb = [parseInt(hex.slice(1,3),16), parseInt(hex.slice(3,5),16), parseInt(hex.slice(5,7),16)];
                floodFill(pos.x, pos.y, rgb);
                saveState();
                return;
            }
            isDrawing = true;
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
        }

        window.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const pos = getPos(e);
            ctx.lineWidth = lineWidth.value;
            ctx.strokeStyle = currentMode === 'eraser' ? "white" : colorPicker.value;
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!isDrawing) return;
            const pos = getPos(e);
            ctx.lineWidth = lineWidth.value;
            ctx.strokeStyle = currentMode === 'eraser' ? "white" : colorPicker.value;
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }, {passive: false});

        window.addEventListener('mouseup', () => { if(isDrawing) { isDrawing = false; saveState(); } });
        window.addEventListener('touchend', () => { if(isDrawing) { isDrawing = false; saveState(); } });

        // ë²„íŠ¼ ë§¤í•‘
        document.getElementById('undoBtn').onclick = undo;
        document.getElementById('redoBtn').onclick = redo;
        document.getElementById('penBtn').onclick = () => { currentMode = 'pen'; setBtn('penBtn'); };
        document.getElementById('eraserBtn').onclick = () => { currentMode = 'eraser'; setBtn('eraserBtn'); };
        document.getElementById('fillBtn').onclick = () => { currentMode = 'fill'; setBtn('fillBtn'); };
        
        function setBtn(id) {
            ['penBtn', 'eraserBtn', 'fillBtn'].forEach(b => document.getElementById(b).classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        document.getElementById('clearBtn').onclick = () => {
            ctx.fillStyle = "white"; ctx.fillRect(0, 0, canvas.width, canvas.height); saveState();
        };

        document.getElementById('saveBtn').onclick = () => {
            const a = document.createElement('a'); a.href = canvas.toDataURL(); a.download = 'art.png'; a.click();
        };

        window.onload = initCanvas;
    </script>
</body>
</html>
